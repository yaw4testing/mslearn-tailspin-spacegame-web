---
AWSTemplateFormatVersion: "2010-09-09"
Description: Systems Performance Infrastructure Stack
Transform: AWS::Serverless-2016-10-31

Parameters:

  Domain:
    Description: Domain
    Type: String
    Default: dx

  Environment:
    Description: The name of the environment that is being deployed to.
    Type: String

  DxLShortEnvironmentName:
    Description: The short name of the environment that is being deployed to.
    Type: String

  Division:
    Description: Tag for the division of the resource
    Type: String

  Program:
    Description: Tag for the program of the resource
    Type: String

  Team:
    Description: Tag for the team of the resource
    Type: String
    Default: pace

  KhaosApiPort:
    Description: The container port for the khaos api
    Type: Number
    Default: 8000

  LocustEcsServicePort:
    Description: Port on which locust service will run
    Type: String
    Default: 8089

  LocustAdminPort:
    Description: Port on which locust admin service will run
    Type: String
    Default: 8090

  WiremockEcsServicePort:
    Description: Port on which wiremock service will run
    Type: String
    Default: 8080

  ReportingEsVpcEndpointId:
    Description: ReportingEsVpcEndpointId
    Type: String

  PrivateHostedZoneName:
    Description: ID of the public hosted zone to be used for externally accessible resources
    Type: String
    Default: pace-reporting.internal.vodafoneaws.co.uk

  Subnets:
    Description: SSM parameter path to the private subnet collection.
    Type: AWS::SSM::Parameter::Value<List<String>>

  VpcIdSsm:
    Description: System Manager Endpoint of the VPC ID.
    Type: AWS::SSM::Parameter::Value<AWS::EC2::VPC::Id>

  VpcCidr:
    Description: Systems manager parameter for the Vpc Cidr block
    Type: AWS::SSM::Parameter::Value<String>

  BastionSecurityGroup:
    Description: Bastion Security Group
    Type: AWS::SSM::Parameter::Value<AWS::EC2::SecurityGroup::Id>

  VstsToolingSecurityGroup:
    Description: SSM Path of the bastion security group
    Type: 'AWS::SSM::Parameter::Value<String>'

  NlbSubnetsCidrCollection:
    Description: SSM parameter path to the private subnets CIDR ranges
    Type: AWS::SSM::Parameter::Value<CommaDelimitedList>

  AppPrivateSubnetsCidrCollection:
    Description: SSM parameter path to the app private subnets CIDR ranges
    Type: AWS::SSM::Parameter::Value<CommaDelimitedList>

  HostedZoneIdSsm:
    Description: ID of the public hosted zone to be used for externally accessible resources
    Type: AWS::SSM::Parameter::Value<String>

  HostedZoneNameSsm:
    Description: ID of the public hosted zone to be used for externally accessible resources
    Type: AWS::SSM::Parameter::Value<String>

  CommonHostedZoneIdSsm:
    Description: ID of the public hosted zone to be used for externally accessible resources
    Type: AWS::SSM::Parameter::Value<String>

  CommonHostedZoneNameSsm:
    Description: ID of the public hosted zone to be used for externally accessible resources
    Type: AWS::SSM::Parameter::Value<String>

  DalApplicationLoadBalancerUrl:
    Description: URL of the DXL (dal) L/B, used for setting up a 'dal-direct....' DNS entry for proxying via WireMock
    Type: AWS::SSM::Parameter::Value<String>

  DalApplicationLoadBalancerCanonicalHostedZoneId:
    Description: canonical hosted zone id of the DXL (dal) L/B, used for setting up a 'dal-direct....' DNS entry for proxying via WireMock
    Type: AWS::SSM::Parameter::Value<String>

  ShopApplicationLoadBalancerUrl:
    Description: URL of the shop (web-shop) L/B, used for setting up a 'shop-direct....' DNS entry for proxying via WireMock
    Type: AWS::SSM::Parameter::Value<String>

  ShopApplicationLoadBalancerCanonicalHostedZoneId:
    Description: canonical hosted zone id of the shop (web-shop) L/B, used for setting up a 'shop-direct....' DNS entry for proxying via WireMock
    Type: AWS::SSM::Parameter::Value<String>

  IdmApplicationLoadBalancerUrl:
    Description: URL of the IDM load balancer, used for setting up a 'idm-direct....' DNS entry for proxying via WireMock
    Type: AWS::SSM::Parameter::Value<String>

  IdmApplicationLoadBalancerCanonicalHostedZoneId:
    Description: canonical hosted zone id of the IDM load balancer, used for setting up a 'idm-direct....' DNS entry for proxying via WireMock
    Type: AWS::SSM::Parameter::Value<String>

  PrivateCertificateArn:
    Description: ssm parameter for wildcard private tls certificate in acm arn
    Type: AWS::SSM::Parameter::Value<String>

  OpensearchDomain:
    Description: name of the dal opensearch domain for the environment
    Type: String

  OpensearchSecurityGroupId:
    Description: ssm parameter for opensearch domain security group id
    Type: AWS::SSM::Parameter::Value<AWS::EC2::SecurityGroup::Id>
  
  AlbLoggingBucket:
    Description: The bucket to store alb access log and the bucket got created as part of vpc stack
    Type: AWS::SSM::Parameter::Value<String>

Conditions:
  # The Reporting VPC Endpoint and DNS can only be created once in each VPC but lower envs share a VPC. Would be better to
  # do this by env specific variable groups but pipelines as YAML don't support that yet.
  UseVpcEndpoint:  !Not [!Or [!Equals [!Ref DxLShortEnvironmentName, "int1"], !Equals [!Ref DxLShortEnvironmentName, "qc1"], !Equals [!Ref DxLShortEnvironmentName, "qc2"]]]

Resources:

  WiremockCertificate:
    Type: AWS::CertificateManager::Certificate
    Properties:
      DomainName: !Sub "*.${HostedZoneNameSsm}"
      SubjectAlternativeNames:
        - !Sub "*.${CommonHostedZoneNameSsm}"
      ValidationMethod: DNS
      Tags:
        - Key: Name
          Value: !Sub "${Domain}-${Environment}-systems-performance-wiremock-certificate"

  WiremockCertificateParameter:
    Type: AWS::SSM::Parameter
    Properties:
      Name: !Sub "/${Domain}/infra/acm/${Environment}/systems-performance-wiremock"
      Type: String
      Value: !Ref WiremockCertificate
      Description: !Sub "The certificate arn for ${Domain}-systems-performance-wiremock in ${Environment}"
      Tags:
        Domain: !Ref Domain
        Division: !Ref Division
        Program: !Ref Program
        Team: !Ref Team

  WiremockAlbSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: "The security group for the Wiremock ALB"
      VpcId: !Ref VpcIdSsm
      SecurityGroupIngress:
        - Description: Allow access from the Bastion to the ALB
          IpProtocol: "tcp"
          FromPort: !Ref "WiremockEcsServicePort"
          ToPort: !Ref "WiremockEcsServicePort"
          SourceSecurityGroupId: !Ref BastionSecurityGroup
        - Description: Allow access from the Bastion to the ALB
          IpProtocol: "tcp"
          FromPort: 443
          ToPort: 443
          SourceSecurityGroupId: !Ref BastionSecurityGroup
        - Description: Allow access from the Bastion to the ALB
          IpProtocol: "tcp"
          FromPort: 6247
          ToPort: 6247
          SourceSecurityGroupId: !Ref BastionSecurityGroup
        - Description: Allow access from the Bastion to the ALB
          IpProtocol: "tcp"
          FromPort: 6347
          ToPort: 6347
          SourceSecurityGroupId: !Ref BastionSecurityGroup
        - Description: Allow access from the Bastion to the ALB
          IpProtocol: "tcp"
          FromPort: 8040
          ToPort: 8040
          SourceSecurityGroupId: !Ref BastionSecurityGroup
          # TODO - Remove unused ports
        - Description: Allow access from DXL to the ALB
          IpProtocol: "tcp"
          FromPort: 443
          ToPort: 443
          CidrIp: !Select [ 0, !Ref AppPrivateSubnetsCidrCollection ]
        - Description: Allow access from DXL to the ALB
          IpProtocol: "tcp"
          FromPort: 443
          ToPort: 443
          CidrIp: !Select [ 1, !Ref AppPrivateSubnetsCidrCollection ]
        - Description: Allow access from DXL to the ALB
          IpProtocol: "tcp"
          FromPort: 443
          ToPort: 443
          CidrIp: !Select [ 2, !Ref AppPrivateSubnetsCidrCollection ]
        - Description: Allow access from DXL to the ALB
          IpProtocol: "tcp"
          FromPort: 6247
          ToPort: 6247
          CidrIp: !Select [ 0, !Ref AppPrivateSubnetsCidrCollection ]
        - Description: Allow access from DXL to the ALB
          IpProtocol: "tcp"
          FromPort: 6247
          ToPort: 6247
          CidrIp: !Select [ 1, !Ref AppPrivateSubnetsCidrCollection ]
        - Description: Allow access from DXL to the ALB
          IpProtocol: "tcp"
          FromPort: 6247
          ToPort: 6247
          CidrIp: !Select [ 2, !Ref AppPrivateSubnetsCidrCollection ]
        - Description: Allow access from DXL to the ALB
          IpProtocol: "tcp"
          FromPort: 6347
          ToPort: 6347
          CidrIp: !Select [ 0, !Ref AppPrivateSubnetsCidrCollection ]
        - Description: Allow access from DXL to the ALB
          IpProtocol: "tcp"
          FromPort: 6347
          ToPort: 6347
          CidrIp: !Select [ 1, !Ref AppPrivateSubnetsCidrCollection ]
        - Description: Allow access from DXL to the ALB
          IpProtocol: "tcp"
          FromPort: 6347
          ToPort: 6347
          CidrIp: !Select [ 2, !Ref AppPrivateSubnetsCidrCollection ]
        - Description: Allow access from DXL to the ALB
          IpProtocol: "tcp"
          FromPort: 8040
          ToPort: 8040
          CidrIp: !Select [ 0, !Ref AppPrivateSubnetsCidrCollection ]
        - Description: Allow access from DXL to the ALB
          IpProtocol: "tcp"
          FromPort: 8040
          ToPort: 8040
          CidrIp: !Select [ 1, !Ref AppPrivateSubnetsCidrCollection ]
        - Description: Allow access from DXL to the ALB
          IpProtocol: "tcp"
          FromPort: 8040
          ToPort: 8040
          CidrIp: !Select [ 2, !Ref AppPrivateSubnetsCidrCollection ]
        - Description: Allow access from API GW to the ALB
          IpProtocol: "tcp"
          FromPort: 443
          ToPort: 443
          CidrIp: !Select [ 0, !Ref NlbSubnetsCidrCollection ]
        - Description: Allow access from API GW to the ALB
          IpProtocol: "tcp"
          FromPort: 443
          ToPort: 443
          CidrIp: !Select [ 1, !Ref NlbSubnetsCidrCollection ]
        - Description: Allow access from API GW to the ALB
          IpProtocol: "tcp"
          FromPort: 443
          ToPort: 443
          CidrIp: !Select [ 2, !Ref NlbSubnetsCidrCollection ]
        - Description: Allow inbound https access from whole vpc to allow any app to talk to wiremock
          IpProtocol: "tcp"
          FromPort: 443
          ToPort: 443
          CidrIp: !Ref VpcCidr
      Tags:
        - Key: Name
          Value: !Sub "${Domain}-${Environment}-systems-performance-wiremock-alb-security-group"
        - Key: Domain
          Value: !Ref Domain
        - Key: Division
          Value: !Ref Division
        - Key: Program
          Value: !Ref Program
        - Key: Team
          Value: !Ref Team

  WiremockAlbSecurityGroupEgress:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      GroupId: !GetAtt WiremockAlbSecurityGroup.GroupId
      IpProtocol: "tcp"
      FromPort: !Ref WiremockEcsServicePort
      ToPort: !Ref WiremockEcsServicePort
      DestinationSecurityGroupId: !GetAtt WiremockContainerSecurityGroup.GroupId
      Description: "Allow outbound traffic to wiremock container secgroup"

  WiremockAlbSecurityGroupIdSsm:
    Type: AWS::SSM::Parameter
    Properties:
      Name: !Sub "/${Domain}/infra/security-group/${Environment}/systems-performance-wiremock-api-alb-sg-id"
      Type: "String"
      Value: !GetAtt WiremockAlbSecurityGroup.GroupId
      Description: !Sub "The ALB security group id for ${Domain}-systems-performance-wiremock in ${Environment}"
      Tags:
        Name: !Sub "${Domain}-${Environment}-systems-performance-wiremock-security-group-id"
        Domain: !Ref Domain
        Division: !Ref Division
        Program: !Ref Program
        Team: !Ref Team


  WiremockContainerSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: "The security group for Wiremock Fargate containers"
      VpcId: !Ref VpcIdSsm
      SecurityGroupIngress:
        - Description: Allow HTTP from the ALB to the Fargate cluster
          IpProtocol: "tcp"
          FromPort: !Ref "WiremockEcsServicePort"
          ToPort: !Ref "WiremockEcsServicePort"
          SourceSecurityGroupId: !Ref WiremockAlbSecurityGroup
        - Description: Allow HTTP from the Khaos controller
          IpProtocol: "tcp"
          FromPort: !Ref "WiremockEcsServicePort"
          ToPort: !Ref "WiremockEcsServicePort"
          SourceSecurityGroupId: !Ref KhaosContainerSecurityGroup
        - Description: Allow remote debug of wiremock
          IpProtocol: "tcp"
          FromPort: 8000
          ToPort: 8000
          SourceSecurityGroupId: !Ref BastionSecurityGroup
      SecurityGroupEgress:
        # TODO: because we currently don't have VPC Service Endpoints restricting to
        # private VPC traffic will cause CannotPullContainer error in Fargate.
        - IpProtocol: "tcp"
          FromPort: 0
          ToPort: 65535
          CidrIp: "0.0.0.0/0"
          Description: "TODO: temporary rule allow all TCP traffic"
      Tags:
        - Key: Name
          Value: !Sub "${Domain}-${Environment}-wiremock-container-sg"
        - Key: Domain
          Value: !Ref Domain
        - Key: Division
          Value: !Ref "Division"
        - Key: Program
          Value: !Ref "Program"
        - Key: Team
          Value: !Ref Team

  WiremockContainerSecurityGroupIdSsm:
    Type: AWS::SSM::Parameter
    Properties:
      Name: !Sub "/${Domain}/infra/security-group/${Environment}/systems-performance-wiremock-container-sg-id"
      Type: "String"
      Value: !GetAtt WiremockContainerSecurityGroup.GroupId
      Description: !Sub "The container security group id for ${Domain}-systems-performance-wiremock in ${Environment}"
      Tags:
        Name: !Sub "${Domain}-${Environment}-systems-performance-wiremock-container-security-group-id"
        Domain: !Ref Domain
        Division: !Ref Division
        Program: !Ref Program
        Team: !Ref Team


  LocustUIAlbSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: "The Locust UI security group for services that need to access Locust"
      VpcId: !Ref VpcIdSsm
      SecurityGroupIngress:
        - Description: Allow HTTP from Bastion to the Fargate cluster
          IpProtocol: "tcp"
          FromPort: !Ref "LocustEcsServicePort"
          ToPort: !Ref "LocustEcsServicePort"
          SourceSecurityGroupId: !Ref BastionSecurityGroup
        - Description: Allow HTTPS from Bastion to the Fargate cluster
          IpProtocol: "tcp"
          FromPort: 443
          ToPort: 443
          SourceSecurityGroupId: !Ref BastionSecurityGroup
        - Description: Allow HTTP from Bastion to the Fargate cluster
          IpProtocol: "tcp"
          FromPort: 80
          ToPort: 80
          SourceSecurityGroupId: !Ref BastionSecurityGroup
        - Description: Allow admin HTTPS from VSTS agents
          IpProtocol: "tcp"
          FromPort: 8443
          ToPort: 8443
          SourceSecurityGroupId: !Ref VstsToolingSecurityGroup
        - Description: Allow HTTPS access from khaos controller
          IpProtocol: "tcp"
          FromPort: 443
          ToPort: 443
          SourceSecurityGroupId: !Ref KhaosContainerSecurityGroup
      Tags:
        - Key: Name
          Value: !Sub "${Domain}-${Environment}--systems-performance-locust-ui-sg"
        - Key: Domain
          Value: !Ref Domain
        - Key: Division
          Value: !Ref Division
        - Key: Program
          Value: !Ref Program
        - Key: Team
          Value: !Ref Team

  LocustUIAlbSecurityGroupEgress:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      GroupId: !GetAtt LocustUIAlbSecurityGroup.GroupId
      IpProtocol: "tcp"
      FromPort: !Ref LocustEcsServicePort
      ToPort: !Ref LocustEcsServicePort
      DestinationSecurityGroupId: !GetAtt LocustContainerSecurityGroup.GroupId
      Description: "Allow outbound traffic to locust container secgroup"
  LocustAdminAlbSecurityGroupEgress:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      GroupId: !GetAtt LocustUIAlbSecurityGroup.GroupId
      IpProtocol: "tcp"
      FromPort: !Ref LocustAdminPort
      ToPort: !Ref LocustAdminPort
      DestinationSecurityGroupId: !GetAtt LocustContainerSecurityGroup.GroupId
      Description: "Allow outbound traffic to locust container secgroup"

  LocustContainerSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: "The security group for Fargate containers"
      VpcId: !Ref VpcIdSsm
      SecurityGroupIngress:
        - Description: Allow HTTP from the ALB to the Fargate cluster
          IpProtocol: "tcp"
          FromPort: !Ref "LocustEcsServicePort"
          ToPort: !Ref "LocustEcsServicePort"
          SourceSecurityGroupId: !Ref LocustUIAlbSecurityGroup
        - Description: Allow HTTP from the ALB to the Fargate cluster healthcheck port
          IpProtocol: "tcp"
          FromPort: !Ref "LocustAdminPort"
          ToPort: !Ref "LocustAdminPort"
          SourceSecurityGroupId: !Ref LocustUIAlbSecurityGroup
        - Description: Allow HTTP from the Bastion to the Fargate cluster healthcheck port
          IpProtocol: "tcp"
          FromPort: !Ref "LocustAdminPort"
          ToPort: !Ref "LocustAdminPort"
          SourceSecurityGroupId: !Ref BastionSecurityGroup
        - Description: Allow Controller from the ALB to the Fargate cluster
          IpProtocol: "tcp"
          FromPort: 5557
          ToPort: 5557
          SourceSecurityGroupId: !Ref LocustUIAlbSecurityGroup
      SecurityGroupEgress:
        # TODO: because we currently don't have VPC Service Endpoints restricting to
        # private VPC traffic will cause CannotPullContainer error in Fargate.
        - IpProtocol: "tcp"
          FromPort: 0
          ToPort: 65535
          CidrIp: "0.0.0.0/0"
          Description: "TODO: temporary rule allow all TCP traffic"
      Tags:
        - Key: Name
          Value: !Sub "${Domain}-${Environment}--locust-container-sg"
        - Key: Domain
          Value: !Ref Domain
        - Key: Division
          Value: !Ref Division
        - Key: Program
          Value: !Ref Program
        - Key: Team
          Value: !Ref Team

  LocustUIAlbSecurityGroupIdSsm:
    Type: AWS::SSM::Parameter
    Properties:
      Name: !Sub "/${Domain}/infra/security-group/${Environment}/systems-performance-locust-ui-alb-sg-id"
      Type: "String"
      Value: !GetAtt LocustUIAlbSecurityGroup.GroupId
      Description: !Sub "Locust HTTPS UI security group id for ${Environment} environment"
      Tags:
        Name: !Sub "${Domain}-${Environment}--systems-performance-locust-ui-alb-sg-id-parameter"
        Domain: !Ref Domain
        Division: !Ref Division
        Program: !Ref Program
        Team: !Ref Team


  LocustContainerSecurityGroupIdSsm:
    Type: AWS::SSM::Parameter
    Properties:
      Name: !Sub "/${Domain}/infra/security-group/${Environment}/systems-performance-locust-container-sg-id"
      Type: "String"
      Value: !GetAtt LocustContainerSecurityGroup.GroupId
      Description: !Sub "Locust container security group id for ${Environment} environment"
      Tags:
        Name: !Sub "${Domain}-${Environment}--systems-performance-locust-container-sg-id-parameter"
        Domain: !Ref Domain
        Division: !Ref Division
        Program: !Ref Program
        Team: !Ref Team

  KhaosApiAlbSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: "The security group for the Khaos Api ALB"
      VpcId: !Ref VpcIdSsm
      SecurityGroupIngress:
        - Description: Allow HTTPS from Bastion to the Fargate cluster
          IpProtocol: "tcp"
          FromPort: 443
          ToPort: 443
          SourceSecurityGroupId: !Ref BastionSecurityGroup
        - Description: Allow admin HTTPS from VSTS agents
          IpProtocol: "tcp"
          FromPort: 443
          ToPort: 443
          SourceSecurityGroupId: !Ref VstsToolingSecurityGroup
      Tags:
        - Key: Name
          Value: !Sub "${Domain}-${Environment}--khaos-api-alb-security-group"
        - Key: Domain
          Value: !Ref Domain
        - Key: Division
          Value: !Ref Division
        - Key: Program
          Value: !Ref Program
        - Key: Team
          Value: !Ref Team

  KhaosApiAlbSecurityGroupEgress:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      GroupId: !GetAtt KhaosApiAlbSecurityGroup.GroupId
      IpProtocol: "tcp"
      FromPort: !Ref KhaosApiPort
      ToPort: !Ref KhaosApiPort
      DestinationSecurityGroupId: !GetAtt KhaosContainerSecurityGroup.GroupId
      Description: "Allow outbound traffic to khaos container secgroup"

  KhaosContainerSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: "The security group for the systems performance khaos controller"
      VpcId: !Ref VpcIdSsm
      SecurityGroupIngress:
        - IpProtocol: "tcp"
          FromPort: !Ref KhaosApiPort
          ToPort: !Ref KhaosApiPort
          SourceSecurityGroupId: !Ref BastionSecurityGroup
          Description: "Allow inbound traffic from bastion for testing purposes"
        - IpProtocol: "tcp"
          FromPort: !Ref KhaosApiPort
          ToPort: !Ref KhaosApiPort
          SourceSecurityGroupId: !Ref KhaosApiAlbSecurityGroup
          Description: "Allow inbound traffic from lb security group"
      SecurityGroupEgress:
        # TODO: because we currently don't have VPC Service Endpoints restricting to
        # private VPC traffic will cause CannotPullContainer error in Fargate.
        - IpProtocol: "tcp"
          FromPort: 0
          ToPort: 65535
          CidrIp: "0.0.0.0/0"
          Description: "TODO: temporary rule allow all TCP traffic"
      Tags:
        - Key: Name
          Value: !Sub "${Domain}-${Environment}--khaos-api-alb-security-group"
        - Key: Domain
          Value: !Ref Domain
        - Key: Division
          Value: !Ref Division
        - Key: Program
          Value: !Ref Program
        - Key: Team
          Value: !Ref Team

  KhaosContainerToWiremockSecGroupEgress:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      GroupId: !GetAtt KhaosContainerSecurityGroup.GroupId
      IpProtocol: "tcp"
      FromPort: 443
      ToPort: 443
      DestinationSecurityGroupId: !GetAtt WiremockAlbSecurityGroup.GroupId
      Description: "Allow outbound traffic to wiremock Alb secgroup"
  KhaosContainerToLocustSecGroupEgress:
    Type: AWS::EC2::SecurityGroupEgress
    Properties:
      GroupId: !GetAtt KhaosContainerSecurityGroup.GroupId
      IpProtocol: "tcp"
      FromPort: 443
      ToPort: 443
      DestinationSecurityGroupId: !GetAtt LocustUIAlbSecurityGroup.GroupId
      Description: "Allow outbound traffic to locust Alb secgroup"

  KhaosApiAlbSecurityGroupIdSsm:
    Type: AWS::SSM::Parameter
    Properties:
      Name: !Sub "/${Domain}/infra/security-group/${Environment}/systems-khaos-api-alb-sg"
      Type: "String"
      Value: !GetAtt KhaosApiAlbSecurityGroup.GroupId
      Description: !Sub "Khaos API Alb security group for ${Environment} environment"
      Tags:
        Name: !Sub "${Domain}-${Environment}--systems-performance-khaos-api-alb-sg-parameter"
        Domain: !Ref Domain
        Division: !Ref Division
        Program: !Ref Program
        Team: !Ref Team

  KhaosContainerSecurityGroupIdSsm:
    Type: AWS::SSM::Parameter
    Properties:
      Name: !Sub "/${Domain}/infra/security-group/${Environment}/systems-khaos-container-sg"
      Type: "String"
      Value: !GetAtt KhaosContainerSecurityGroup.GroupId
      Description: !Sub "Khaos container security group for ${Environment} environment"
      Tags:
        Name: !Sub "${Domain}-${Environment}--systems-performance-khaos-container-sg-parameter"
        Domain: !Ref Domain
        Division: !Ref Division
        Program: !Ref Program
        Team: !Ref Team

  # VpcEndpoint configuration for reporting
  ReportingEsVpcEndpoint:
    Type: AWS::EC2::VPCEndpoint
    Condition: UseVpcEndpoint
    Properties:
      VpcId: !Ref VpcIdSsm
      ServiceName: !Ref ReportingEsVpcEndpointId
      VpcEndpointType: Interface
      SubnetIds: !Ref Subnets
      SecurityGroupIds:
        - !Ref ReportingEsVpcEndPointSecurityGroup

  ReportingEsPrivateHostedZone:
    Type: AWS::Route53::HostedZone
    Condition: UseVpcEndpoint
    Properties:
      HostedZoneConfig:
        Comment: !Sub Private hosted zone for ${AWS::StackName}
      Name: !Sub ${PrivateHostedZoneName}
      VPCs:
        - VPCId: !Ref VpcIdSsm
          VPCRegion: !Ref AWS::Region
      HostedZoneTags:
        - Key: Name
          Value: !Sub ${Domain}-${Environment}-private-hosted-zone
  
  ReportingEsVpcEndpointDNSRecord:
    Type: AWS::Route53::RecordSet
    Condition: UseVpcEndpoint
    Properties:
      HostedZoneId: !Ref ReportingEsPrivateHostedZone
      Comment: "DNS name for the vpc endpoint"
      Type: CNAME
      TTL: "60"
      Name: !Sub 'es.${PrivateHostedZoneName}'
      ResourceRecords:
        - !Select [1, !Split [":", !Select [0, !GetAtt ReportingEsVpcEndpoint.DnsEntries]]]

  ReportingEsVpcEndpointDNSRecordSsm:
    Type: 'AWS::SSM::Parameter'
    Condition: UseVpcEndpoint
    Properties:
      Name: !Sub '/${Domain}/elasticseaerch/${Environment}/pace-reporting-endpoint'
      Type: 'String'
      Value: !Sub 'es.${PrivateHostedZoneName}'
      Description: !Sub 'Private hosted zone name for Pace Reporting in ${Environment} environment'
      Tags:
        Name: !Sub "${Domain}-${Environment}--private-hosted-zone-for-pace-reporting"
        Domain: !Ref Domain
        Division: !Ref Division
        Program: !Ref Program
        Team: !Ref Team

  ReportingEsVpcEndPointSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Condition: UseVpcEndpoint
    Properties:
      GroupName: !Sub "${Domain}-${Environment}-test-report-es-vpc-endpoint-sg"
      GroupDescription: !Sub "${Domain}-${Environment}-test-report-es-vpc-endpoint-sg"
      VpcId: !Ref VpcIdSsm
      SecurityGroupIngress:
        - Description: Allow HTTPS from Bastion to the Fargate cluster
          IpProtocol: "tcp"
          FromPort: 443
          ToPort: 443
          SourceSecurityGroupId: !Ref BastionSecurityGroup
        - Description: Allow HTTPS from  the Fargate cluster
          IpProtocol: "tcp"
          FromPort: 443
          ToPort: 443
          SourceSecurityGroupId: !Ref LocustContainerSecurityGroup
        - Description: Allow HTTPS from Khaos controller container
          IpProtocol: "tcp"
          FromPort: 443
          ToPort: 443
          SourceSecurityGroupId: !Ref KhaosContainerSecurityGroup
        - Description: Allow HTTPS from  the Release Agents
          IpProtocol: "tcp"
          FromPort: 443
          ToPort: 443
          SourceSecurityGroupId: !Ref VstsToolingSecurityGroup
      SecurityGroupEgress:
        - IpProtocol: "-1"
          FromPort: -1
          ToPort: -1
          CidrIp: "0.0.0.0/0"
          Description: "Allow all outbound traffic"
      Tags:
        - Key: Name
          Value: !Sub "${Domain}-${Environment}-test-report-es-vpc-endpoint-sg"
        - Key: Domain
          Value: !Ref Domain
        - Key: Division
          Value: !Ref Division
        - Key: Program
          Value: !Ref Program
        - Key: Team
          Value: !Ref Team

  DalDirectDnsRecordForWireMockProxying:
    Type: AWS::Route53::RecordSet
    Properties:
      HostedZoneId: !Ref HostedZoneIdSsm
      Comment: "DNS name for routing traffic from WireMock to DXL when the dal.dx-... domain name has been redirected to WireMock"
      Type: A
      Name: !Sub "dal-direct.${HostedZoneNameSsm}"
      AliasTarget:
        DNSName: !Ref DalApplicationLoadBalancerUrl
        HostedZoneId: !Ref DalApplicationLoadBalancerCanonicalHostedZoneId

  ShopDirectDnsRecordForWireMockProxying:
    Type: AWS::Route53::RecordSet
    Properties:
      HostedZoneId: !Ref HostedZoneIdSsm
      Comment: "DNS name for routing traffic from WireMock to shop when the shop.dx-... domain name has been redirected to WireMock"
      Type: A
      Name: !Sub "shop-direct.${HostedZoneNameSsm}"
      AliasTarget:
        DNSName: !Ref ShopApplicationLoadBalancerUrl
        HostedZoneId: !Ref ShopApplicationLoadBalancerCanonicalHostedZoneId

  IdmDirectDnsRecordForWireMockProxying:
    Type: AWS::Route53::RecordSet
    Properties:
      HostedZoneId: !Ref CommonHostedZoneIdSsm
      Comment: "DNS name for routing traffic from WireMock to shop when the idm.dx-... domain name has been redirected to WireMock"
      Type: A
      Name: !Sub "idm-direct.${CommonHostedZoneNameSsm}"
      AliasTarget:
        DNSName: !Ref IdmApplicationLoadBalancerUrl
        HostedZoneId: !Ref IdmApplicationLoadBalancerCanonicalHostedZoneId

  # We need to convert this to a wcs-direct record, pointing at the original target, as the WCS stack
  # should create the wcs record.
  #  WcsWiremockAlbDNSRecord:
  #    Type: AWS::Route53::RecordSet
  #    Properties:
  #      HostedZoneId: !Ref HostedZoneIdSsm
  #      Comment: 'WCS dns name for wiremock stubbing'
  #      Type: A
  #      Name: !Sub 'wcs.${HostedZoneNameSsm}'
  #      AliasTarget:
  #        DNSName: !GetAtt WiremockAlb.DNSName
  #        HostedZoneId: !GetAtt WiremockAlb.CanonicalHostedZoneID

  #  This load balancer is used to present a custom domain certificate in front of elasticsearch without
  #  the need to update the certificate on the cluster, as this would only be possible with downtime or
  #  replacing the cluster over several deployment cycles. This is required by pace in order to achieve dns
  #  switching between elasticsearch and wiremock.
  OpensearchLoadBalancer:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Type: network
      Scheme: internal
      Subnets: !Ref Subnets
      LoadBalancerAttributes:
        - Key: access_logs.s3.enabled
          Value: "true"
        - Key: access_logs.s3.bucket
          Value: !Ref AlbLoggingBucket
        - Key: access_logs.s3.prefix
          Value: elb-access-logs
      Tags:
        - Key: Name
          Value: !Sub "${Domain}-${Environment}-opensearch-dns-endpoint-load-balancer"
        - Key: Domain
          Value: !Ref Domain
        - Key: Division
          Value: !Ref Division
        - Key: Program
          Value: !Ref Program
        - Key: Team
          Value: !Ref Team

  OpensearchLoadBalancerDnsNameParameter:
    Type: AWS::SSM::Parameter
    Properties:
      Name: !Sub "/${Domain}/infra/load-balancer/${Environment}/opensearch-${OpensearchDomain}-dns-name"
      Type: String
      Value: !GetAtt OpensearchLoadBalancer.DNSName
      Description: !Sub "${OpensearchDomain} load balancer dns name for ${Environment} environment"
      Tags:
        Name: !Sub "${Domain}-${Environment}-opensearch-dns-endpoint-load-balancer-dns-name-parameter"
        Domain: !Ref Domain
        Division: !Ref Division
        Program: !Ref Program
        Team: !Ref Team  

  OpensearchLoadBalancerCanonicalHostedZoneIdParameter:
    Type: AWS::SSM::Parameter
    Properties:
      Name: !Sub "/${Domain}/infra/load-balancer/${Environment}/opensearch-${OpensearchDomain}-canonical-hosted-zone-id"
      Type: String
      Value: !GetAtt OpensearchLoadBalancer.CanonicalHostedZoneID
      Description: !Sub "${OpensearchDomain} load balancer canonical hosted zone id for ${Environment} environment"
      Tags:
        Name: !Sub "${Domain}-${Environment}-opensearch-dns-endpoint-load-balancer-canonical-hosted-zone-id-parameter"
        Domain: !Ref Domain
        Division: !Ref Division
        Program: !Ref Program
        Team: !Ref Team

  OpensearchDnsRecordForWireMockProxying:
    Type: AWS::Route53::RecordSet
    Properties:
      HostedZoneId: !Ref HostedZoneIdSsm
      Comment: "DNS name for routing traffic from WireMock to elasticsearch when the domain name has been redirected to WireMock"
      Type: A
      Name: !Sub "es-direct.${HostedZoneNameSsm}"
      AliasTarget:
        DNSName: !GetAtt OpensearchLoadBalancer.DNSName
        HostedZoneId: !GetAtt OpensearchLoadBalancer.CanonicalHostedZoneID

  OpensearchTargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      VpcId: !Ref VpcIdSsm
      TargetType: ip
      Protocol: TLS
      Port: 443
      HealthCheckPort: 443
      HealthCheckProtocol: TCP
      Tags:
        - Key: Name
          Value: !Sub "${Domain}-${Environment}-opensearch-dns-endpoint-target-group"
        - Key: Domain
          Value: !Ref Domain
        - Key: Division
          Value: !Ref Division
        - Key: Program
          Value: !Ref Program
        - Key: Team
          Value: !Ref Team
        

  OpensearchLoadBalancerTlsListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      LoadBalancerArn: !Sub "arn:aws:elasticloadbalancing:${AWS::Region}:${AWS::AccountId}:loadbalancer/${OpensearchLoadBalancer.LoadBalancerFullName}"
      Port: 443
      Protocol: TLS
      SslPolicy: ELBSecurityPolicy-TLS13-1-2-2021-06
      Certificates:
        - CertificateArn: !Ref PrivateCertificateArn
      DefaultActions:
        - Type: forward
          TargetGroupArn: !Sub "arn:aws:elasticloadbalancing:${AWS::Region}:${AWS::AccountId}:${OpensearchTargetGroup.TargetGroupFullName}"

  OpensearchTargetGroupManagementRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Path: /
      Policies:
        - PolicyName: Lambda-ALBasTarget
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Sid: LambdaLogging
                Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource:
                  - !Sub arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*
              - Sid: QueryEc2LoadBalancing
                Effect: Allow
                Action:
                  - ec2:DescribeSecurityGroups
                  - ec2:DescribeNetworkInterfaces
                  - ec2:CreateNetworkInterface
                  - ec2:DeleteNetworkinterface
                  - elasticloadbalancing:DescribeTargetHealth
                Resource: "*" # required for above actions
                
              - Sid: ModifyLoadBalancing
                Effect: Allow
                Action:
                  - elasticloadbalancing:RegisterTargets
                  - elasticloadbalancing:DeregisterTargets
                  - ec2:AuthorizeSecurityGroupIngress
                  - ec2:RevokeSecurityGroupIngress
                Resource:
                  - !Sub "arn:aws:elasticloadbalancing:${AWS::Region}:${AWS::AccountId}:${OpensearchTargetGroup.TargetGroupFullName}"
                  - !Sub "arn:aws:ec2:${AWS::Region}:${AWS::AccountId}:security-group/${OpensearchSecurityGroupId}"
                  
      Tags:
        - Key: Name
          Value: !Sub "${Domain}-${Environment}-opensearch-dns-endpoint-target-group-management-role"
        - Key: Domain
          Value: !Ref Domain
        - Key: Division
          Value: !Ref Division
        - Key: Program
          Value: !Ref Program
        - Key: Team
          Value: !Ref Team

  OpensearchTargetGroupManagement:
    Type: AWS::Serverless::Function
    Properties:
      Description: Register eni ip addresses for opensearch cluster to network load balancer target group
      Handler: index.lambda_handler
      InlineCode: |
        import os
        from typing import List

        import boto3

        ec2_client = boto3.client('ec2', region_name=os.environ['AWS_REGION'])
        elbv2_client = boto3.client('elbv2', region_name=os.environ['AWS_REGION'])


        def lambda_handler(event, context):
            target_group_arn = os.environ['TARGET_GROUP_ARN']
            opensearch_security_group_id = os.environ["OPENSEARCH_SECURITY_GROUP_ID"]
            load_balancer_name = os.environ["LOAD_BALANCER_NAME"]
            opensearch_domain = os.environ["OPENSEARCH_DOMAIN"]

            current_targets = elbv2_client.describe_target_health(TargetGroupArn=target_group_arn)

            nlb_interfaces = ec2_client.describe_network_interfaces(Filters=[
                {
                    'Name': 'description',
                    'Values': [f'ELB {load_balancer_name}']
                },
                {
                    'Name': 'status',
                    'Values': ['in-use']
                },
            ])

            security_group = ec2_client.describe_security_groups(GroupIds=[opensearch_security_group_id])
            security_group_ip_ranges = [ip_range['CidrIp'] for permission in security_group['SecurityGroups'][0]['IpPermissions']
                                        for ip_range in permission['IpRanges']
                                        if ip_range['Description'] == f'ELB {load_balancer_name}']
            print(f'current authorised security group ranges: {security_group_ip_ranges}')

            nlb_in_use_ip_ranges = [f"{interface['PrivateIpAddress']}/32" for interface in nlb_interfaces['NetworkInterfaces']]
            print(f'in-use load balancer ranges: {nlb_in_use_ip_ranges}')

            ranges_to_authorise, ranges_to_revoke = determine_targets_to_register_and_deregister(security_group_ip_ranges,
                                                                                                 nlb_in_use_ip_ranges)
            print(f'will authorise: {ranges_to_authorise} and revoke: {ranges_to_revoke}')

            if ranges_to_authorise:
                print(f'authorising {ranges_to_authorise}')
                ec2_client.authorize_security_group_ingress(
                    GroupId=opensearch_security_group_id,
                    IpPermissions=[{
                        'IpProtocol': 'tcp',
                        'FromPort': 443,
                        'ToPort': 443,
                        'IpRanges': [{'CidrIp': range, 'Description': f'ELB {load_balancer_name}'}
                                     for range in ranges_to_authorise]}])

            if ranges_to_revoke:
                print(f'revoking {ranges_to_revoke}')
                ec2_client.revoke_security_group_ingress(
                    GroupId=opensearch_security_group_id,
                    IpPermissions=[{
                        'IpProtocol': 'tcp',
                        'FromPort': 443,
                        'ToPort': 443,
                        'IpRanges': [{'CidrIp': range, 'Description': f'ELB {load_balancer_name}'}
                                     for range in ranges_to_revoke]}])

            es_interfaces = ec2_client.describe_network_interfaces(Filters=[
                {
                    'Name': 'description',
                    'Values': [f'ES {opensearch_domain}']
                },
                {
                    'Name': 'status',
                    'Values': ['in-use']
                },
            ])

            current_target_ip_addresses = [health['Target']['Id'] for health in current_targets['TargetHealthDescriptions']]
            print(f'current target ip addresses: {current_target_ip_addresses}')

            es_in_use_ip_addresses = [interface['PrivateIpAddress'] for interface in es_interfaces['NetworkInterfaces']]
            print(f'in-use opensearch ip addresses: {es_in_use_ip_addresses}')

            targets_to_register, targets_to_deregister = determine_targets_to_register_and_deregister(current_target_ip_addresses,
                                                                                                      es_in_use_ip_addresses)
            print(f'will register: {targets_to_register} and deregister: {targets_to_deregister}')

            if targets_to_register:
                print(f'registering: {targets_to_register}')
                elbv2_client.register_targets(TargetGroupArn=target_group_arn,
                                              Targets=[{'Id': target} for target in targets_to_register])

            if targets_to_deregister:
                print(f'deregistering: {targets_to_deregister}')
                elbv2_client.deregister_targets(TargetGroupArn=target_group_arn,
                                                Targets=[{'Id': target} for target in targets_to_deregister])


        def determine_targets_to_register_and_deregister(current_target_ip_addresses: List[str],
                                                         es_in_use_ip_addresses: List[str]) -> (List[str], List[str]):
            return (list(set(es_in_use_ip_addresses) - set(current_target_ip_addresses)),
                    list(set(current_target_ip_addresses) - set(es_in_use_ip_addresses)))

      Timeout: 300
      ReservedConcurrentExecutions: 0
      Role: !GetAtt OpensearchTargetGroupManagementRole.Arn
      Runtime: python3.9
      VpcConfig:
       SubnetIds: !Ref Subnets
       SecurityGroupIds:
        - !Ref ReportingEsVpcEndPointSecurityGroup
      Environment:
        Variables:
          LOAD_BALANCER_NAME: !GetAtt OpensearchLoadBalancer.LoadBalancerFullName
          TARGET_GROUP_ARN: !Sub "arn:aws:elasticloadbalancing:${AWS::Region}:${AWS::AccountId}:${OpensearchTargetGroup.TargetGroupFullName}"
          OPENSEARCH_DOMAIN: !Ref OpensearchDomain
          OPENSEARCH_SECURITY_GROUP_ID: !Ref OpensearchSecurityGroupId
      Tags:
         Name: !Sub "${Domain}-${Environment}-opensearch-dns-endpoint-target-group-management"
         Domain: !Ref Domain
         Division: !Ref Division
         Program: !Ref Program
         Team: !Ref Team

  OpensearchTargetGroupManagementScheduledRule:
    Type: AWS::Events::Rule
    Properties:
      Description: ScheduledRule
      ScheduleExpression: rate(1 minute)
      State: ENABLED
      Targets:
        - Arn: !GetAtt OpensearchTargetGroupManagement.Arn
          Id: TargetFunctionV1

  OpensearchTargetGroupManagementLambdaInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt OpensearchTargetGroupManagement.Arn
      Principal: events.amazonaws.com
      Action: lambda:InvokeFunction
      SourceArn: !GetAtt OpensearchTargetGroupManagementScheduledRule.Arn

